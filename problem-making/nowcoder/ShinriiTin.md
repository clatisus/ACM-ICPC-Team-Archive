### 未命名1（最值反演 + 树`dfs`）

**题目大意**：

我有一棵树，节点数为$n\le20$。 

一开始每个节点都是白色的。 

现在我在树上随机选择一条路径（即使这条路径上的所有点都已经被染黑），将路径上所有点都染黑（路径长度可以为1）。 

不断重复这个操作，直到所有点都变成黑色。

 问期望的操作次数是多少，取模。  

**题解**：

考虑[容斥](https://en.wikipedia.org/wiki/Maximum-minimums_identity)，枚举集合$S$，计算集合$S$中任意点被染色的最早时间的期望值。

就将集合$S$中的点当做关键点，进行`dfs`，计算有多少条路径不会经过关键点，记为$x$。

则这个期望值就是$\displaystyle \frac{n(n+1)}{2x}$.

时间复杂度$O(n\times2^n)$，空间复杂度$O(n)$.



### 未命名2（`fwt`）

**题目大意**：

我有俩数组$a$和$b$，长度都为$n$（$n$是不大于$2^{18}$的$2$的整次幂），下标从0开始。

求长度同样是$n$的数组$c$，满足$c_k = \sum\limits_{i=0}^{n-1} \sum\limits_{j=0}^{n-1} [i\text{ and }j=0][i\text{ or }j=k] a_i\times b_j$，取模。

**题解**：

构造生成函数$\displaystyle A(x) = \sum\limits_{i=0}^{n-1} a_ix^iy^{bitcnt(i)}$和$\displaystyle B(x) = \sum\limits_{i=0}^{n-1} b_ix^iy^{bitcnt(i)}$.

令$x^i \cdot x^j = x^{i\text{ or }j}$，则$C(x) = A(x) \otimes B(x)$，$c_k$就是$C(x)$中$x^ky^{bitcnt(k)}$项的系数。

这个乘法可以暴力卷积$y$，然后每次通过`fwt`计算$x$这边的运算。

$y$这边的次数界为$\log{n}$，因此一共需要进行$\log^2{n}$次或运算卷积。

但是注意到参与卷积的两边分别只有$\log{n}$种，我们可以先对它们分别进行`fwt`，之后进行$\log^2{n}$次点积运算，最后使用$\log{n}$次`fwt`逆运算即可。

时间复杂度$O(n\log^2{n})$，空间复杂度$O(n\log{n})$.



### 未命名3（`prim`+线段树+`set`）

**题目大意**：

二分图$G$图左右部各有$n\le100000$个点，和无数条边。

边一共有$m\le200000$类，第$i$类边可以以$w_i$的代价，连接左部的点$x_i$和右部的点$y_i$，满足$x_i\in[a_i,b_i]$，$y_i\in[c_i,d_i]$.

求图$G$的最小生成树的权值和。

**题解**：

考虑`prim`求最小生成树。

用一个优先队列维护当前集合向外连的边，每次都尝试用队首的边加入一个新的点，否则删除队首。

将$m$条边分成$2m$条有向边，则当加入一个新的点到集合中时，需要把起点区间包含该点的所有线段取出进行更新。

使用线段树套`std::vector`来维护线段，每个节点维护左端点在对应区间范围内的线段，并且按右端点排序。

查询时去线段树中查询，不需要打标记，也不需要回溯的时候更新，在线段树外记录一下每个线段是否第一次被取出，重复取出就不管。

时间复杂度$O((n+m)\log{n})$，空间复杂度$O(m\log{n})$.

