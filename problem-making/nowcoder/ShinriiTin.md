### 未命名1（最值反演 + 树`dfs`）

**题目大意**：

我有一棵树，节点数为$n\le20$。 

一开始每个节点都是白色的。 

现在我在树上随机选择一条路径（即使这条路径上的所有点都已经被染黑），将路径上所有点都染黑（路径长度可以为1）。 

不断重复这个操作，直到所有点都变成黑色。

 问期望的操作次数是多少，取模。  

**题解**：

考虑[容斥](https://en.wikipedia.org/wiki/Maximum-minimums_identity)，枚举集合$S$，计算集合$S$中任意点被染色的最早时间的期望值。

就将集合$S$中的点当做关键点，进行`dfs`，计算有多少条路径不会经过关键点，记为$x$。

则这个期望值就是$\displaystyle \frac{n(n+1)}{2x}$.

时间复杂度$O(n\times2^n)$，空间复杂度$O(n)$.



### 未命名2（`fwt`）毙了，或者包装一下不那么裸

**题目大意**：

我有俩数组$a$和$b$，长度都为$n$（$n$是不大于$2^{18}$的$2$的整次幂），下标从0开始。

求长度同样是$n$的数组$c$，满足$c_k = \sum\limits_{i=0}^{n-1} \sum\limits_{j=0}^{n-1} [i\text{ and }j=0][i\text{ or }j=k] a_i\times b_j$，取模。

**题解**：

构造生成函数$\displaystyle A(x) = \sum\limits_{i=0}^{n-1} a_ix^iy^{bitcnt(i)}$和$\displaystyle B(x) = \sum\limits_{i=0}^{n-1} b_ix^iy^{bitcnt(i)}$.

令$x^i \cdot x^j = x^{i\text{ or }j}$，则$C(x) = A(x) \otimes B(x)$，$c_k$就是$C(x)$中$x^ky^{bitcnt(k)}$项的系数。

这个乘法可以暴力卷积$y$，然后每次通过`fwt`计算$x$这边的运算。

$y$这边的次数界为$\log{n}$，因此一共需要进行$\log^2{n}$次或运算卷积。

但是注意到参与卷积的两边分别只有$\log{n}$种，我们可以先对它们分别进行`fwt`，之后进行$\log^2{n}$次点积运算，最后使用$\log{n}$次`fwt`逆运算即可。

时间复杂度$O(n\log^2{n})$，空间复杂度$O(n\log{n})$.



### 未命名3（`prim`+线段树+`set`）原题做法也可以做，毙了，线段树idea单独出出来

**题目大意**：

二分图$G$图左右部各有$n\le100000$个点，和无数条边。

边一共有$m\le200000$类，第$i$类边可以以$w_i$的代价，连接左部的点$x_i$和右部的点$y_i$，满足$x_i\in[a_i,b_i]$，$y_i\in[c_i,d_i]$.

求图$G$的最小生成树的权值和。

**题解**：

考虑`prim`求最小生成树。

用一个优先队列维护当前集合向外连的边，每次都尝试用队首的边加入一个新的点，否则删除队首。

将$m$条边分成$2m$条有向边，则当加入一个新的点到集合中时，需要把起点区间包含该点的所有线段取出进行更新。

使用线段树套`std::vector`来维护线段，每个节点维护左端点在对应区间范围内的线段，并且按右端点排序。

查询时去线段树中查询，不需要打标记，也不需要回溯的时候更新，在线段树外记录一下每个线段是否第一次被取出，重复取出就不管。

时间复杂度$O((n+m)\log{n})$，空间复杂度$O(m\log{n})$.



### 未命名4 （线段树）

**题目大意**： 

有$n$条线段，之后$m$次操作，每次给出一个点$x$，将包含点$x$的线段都删去，输出每次删去的线段个数。

最后，对于每条线段，输出其在第几次操作时被删除，若未被删除则输出0.

（$1\le n,m\le5\times10^5$，$-10^9\le x\le10^9$)

**题解**：

初始化一个线段树，每个节点用一个`std::vector`保存所有左端点在区间内，按右端点从小到大排序的线段。

用归并的方法初始化，时间复杂度$O(n\log{n})$，保存的线段总数为$O(n\log{n})$.

每次询问时在线段树上走到$[1,x]$要问的节点，将右端点大于$x$的线段都从该节点的`std::vector`中删去。

同时删的时候查看该线段是否为第一次从线段树中删除，是则更新答案。

因为线段树中的每个节点最多被删除一次，最终的时间复杂度就是$O(n\log{n})$.