## [E - Sequential operations on Sequence](https://agc003.contest.atcoder.jp/tasks/agc003_e)

**题目大意：**

有一个长度为$nle10^5$的数列，一开始为$1,\cdots,n$.

接下来$q\le10^5$次操作，每次操作使得数列长度变为$1\le A_i\le10^18$。

如果$A_i$小于等于操作前的数列长度，则保留数列前$A_i$项。

如果$A_i$大于操作前的数列长度，则不断循环重复数列直到补足$A_i$项。

**题解：**

如果$i<j$且$A_i\ge A_j$，则第$i$次操作可以被忽略。因此可以得到一个单调上升的操作序列$B$。

考虑将操作过程反过来，从$B_{i+1}$变为$B_i$等价于将线段$[1,B_{i+1}]$变为了$\lfloor\frac{B_{i+1}}{B_i}\rfloor$个$[1,B_i]$和$[1,B_{i+1}\mod{B_i}]$。

一开始只有一个线段，最后答案为$1,\cdots,n$每个位置被多少条线段所覆盖。

用数组$t[i]$维护当前线段$[1,B_i]$的数量，用$k$维护除了$[1,B_j](j<i)$之外的零散线段的右端点，之后不断拆分线段$[1,k]$。

每次找到最大的小于$k$的$B_j$，拆分出$t[i]\times\lfloor\frac{k}{B_j}\rfloor$条线段$[1,B_j]$，然后$k$就变为了$k\mod{B_j}$。

直到$k<=B_1$，这时$k$无法再被拆分，给最终答案的区间$[1,k]$贡献$t[i]$。

因为取模的下降速度很快，是$log$级别的，总的时间复杂度为$O(q\log{q}\log{max_A}+n)$.